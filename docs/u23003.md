# **U23003[^1] USFM References**

M. Hosken

# **Executive Summary**

This document introduces a scheme for biblical references. It aims to allow the referencing of any content in a scripture file down to the character level. In particular it features the ability to reference:

* words & characters  
* notes (footnotes, etc.), section headings, introductory material  
* marker attributes  
* across scripture sources

Some examples

```
MAT 2:1!3      # third word of Matthew chapter 2 verse 1
MAT 2:1!3-4    # words 3-4 of Matthew chapter 2 verse 1
MAT 2:1!3-2!4  # word 3 of Matthew 2:1 to verse 2 word 4
MAT 2:1!3-2:4  # word 3 of Matthew 2:1 to chapter 2 verse 4
MAT 2:1-4      # verse 1 to 4 of Matthew chapter 2
MAT 2-4        # chapters 2 to 4 of Matthew
```

As an extreme example we could use `en-t-wsg+sil.MAT 1:1!f!5+6` for the 6th character in the 5th word in the first footnote in Matthew chapter 1 verse 1 in the wsg back translation (into English) SIL project. Although this is overkill for nearly all situations and nobody would ever type such a thing\!

# **Introduction**

The purpose of this document is to propose a normative basic standard for scripture references. Notice it is not concerned with localised references, even for English. There already exists an informal specification for scripture references which resolves within a particular translation down to the verse level. But there are desires to extend this reference in other directions: 

* To be recognisable as a standard book, chapter, verse reference.  
* To be able to reference text in other translations.  
* To be able to reference a word or even part of a word within a verse.  
* To be able to reference any text, even non scriptural text, within a text file.  
* To be able to inject / associate material (notes, implicit information, illustrations, etc.) directly into the text with surgical precision.  
* To allow milestone-dependent features without having to insert milestone markers into the text

This proposal will examine all of these extensions and propose a grammar for a scripture reference list that includes scripture reference ranges.

# **Basic Reference**

The current basic reference consists of a book ID, a chapter number and a verse number, which may have an informal Verse subsection reference (e.g. a).

```
Reflist = RefRange (ws* Refsep ws* RefRange)*
RefRange = Reference (ws* "-" ws* Reference)?
Reference = Fullref | ContextRef
FullRef = BookId ws+ Chapter (chaptersep Verse)?
ContextRef = Chapter (chaptersep Verse)? | Verse
BookId = capital (capital | digit){2}
	 | digit (capital{2} | digit capital | capital digit)
Refsep = ';' | ','
chaptersep = (":" | ".")
Chapter = digits
Verse = digits subverse? | subverse | "end"
subverse = letter
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
digits = digit+
letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
	   "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" |
	   "u" | "v" | "w" | "x" | "y" | "z"
capital = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | 
	    "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" |
	    "U" | "V" | "W" | "X" | "Y" | "Z"
ws = " " | [\u00A0\u1680\u2000-\u200F\u202A-\u202F\u205F
		\u2066-\u2069\u3000]
```

A BookId is basically 3 digits or capitals of which one must be a capital. If a BookId were all digits it would be confused with a ContextRef.

## **Ranges**

A reference list is a list of verse ranges. A verse range may consist of a single reference or a first and last reference. Notice that verse ranges are inclusive of both the first and last verses. One of the difficulties of verse ranges is that if you want to finish at the end of a chapter, you have to know how many verses are in that chapter. To alleviate that need, we allow the keyword end. Further, it is not uncommon for people to want to reference a whole chapter. For example JHN 3 refers to the whole of John chapter 3\. In effect it is equivalent to `JHN 3:1-end`. The definition of BookId is informal. A full list of book codes may be found in Appendix 1 of this document. All other codes may be considered private use subject to the risk of them gaining a formal definition in the future.

The whole basis of this referencing model is ranges. In effect *a reference is a sequence of steps in range refinement*. A chapter refines the range of a book down to a chapter. A verse refines a chapter range to a verse, etc. The full implications of such thinking becomes more evident when we consider word references or referencing non scripture material held in a scripture file.

## **Contextual References**

In a list of references or within a range, it is common to want to abbreviate a reference in relation to one that precedes it in the list or range. For example `GEN 1:5-23` refers to the 19 verses of Genesis chapter 1\. But the range is two references: `GEN 1:5` and `23`. That 23 is pretty meaningless on its own. It's only because we know that the previous reference is to a verse, that we can read 23 as being a verse reference. But `GEN 5-23` is a range of 19 chapters, since we interpret the 23 here as a chapter reference.

There is a general principle at work here. *Treating a reference as a range, puts that range into the context of a parent*. A verse has its chapter as its parent, and so on. An abbreviated reference is considered to be a refinement of the same parent as the previous reference (or its context).

Revisiting our example,, our first range: `GEN 1:5-23` consists of an initial reference to a verse and is the context for the following abbreviated reference. The parent range for the verse is `GEN 1`. Thus the `23` here is a refinement of `GEN 1`, leading to `GEN 1:23`. On the other hand `GEN 5-23` has an initial chapter reference with a parent of all of `GEN`. The `23` is a refinement of `GEN` leading to chapter 23 and so the second reference is to `GEN 23`.

## **Single Chapter Books**

The book of Jude has only one chapter. What therefore does `JUD 1-4` mean? It could mean Jude chapters 1-4. But that is not valid. Instead interpreting the range as `JUD 1:1-1:4` makes better sense.  In effect a reference to JUD is both a full book range and also a chapter range already. When refining JUD, we in effect are refining JUD 1\. This only applies to primary text references (being discussed now). For other types of references, JUD refers to the whole book.

Unfortunately, it is not possible to resolve whether a book is single chapter or not within the grammar itself and so identifying that `JUD 1-4` in effect means `JUD 1:1-1:4` is up to the processor. This is no different from deciding that `MAT 3:158` is out of range, is not achievable via the grammar and only by the processor.

## **Subverses**

Subverse labelling has no direct correspondence with any text, unless that text has also been marked with subverses. Typically, subverses are used informally and are up to the processor to disambiguate. This proposal makes no attempt to define how to break a verse into subverses where none are marked in the text.

There are two ways of supporting subverses:

1. Only the canonical list of single characters a \- z may be used.  
2. Any characters may be used, but there is no implicit ordering. The order is given by the order in which they occur in the source text. The implication is that no subverses may occur in either end of bridged verses.

Of the two, we propose the first approach as fitting with current and expected usage. The current USFM/X grammar allows for approach 2 without the implied constraint.

## **Versification Schemes**

Different translations may work to different versifications. For example: the NIV has `MAL 3:1-18; 4:1-6` while a typical French translation will have `MAL 3:1-24`. Must references into another translation use its versification?

A scripture reference is interpretted according to the referencing scheme of the scripture being referenced. Thus references to other translations are assumed to be interpretted according to that translation referenced and not the translation from where it was referenced. A higher level protocol (e.g. Module format) may override this to say that references within its file are interpreted according to a different versification. The handling of such matters is outside the scope of this standard.

# **External References**

There are two core questions to resolve when extending references to be able to reference a different translation:

* How to reference a bible translation  
* How to integrate such a reference into a verse reference

## **Translation Reference**

This work builds on discussions held on how to reference not only a translation but a scripture product. In summary, a scripture product reference is a sequence of components separated by `+`. The complete string of components may be truncated at the point where no other information is needed to disambiguate the product / translation. The components are:

### **Language Tag**

The language tag component consists of a [BCP47 language tag](https://www.rfc-editor.org/info/bcp47). The only difference is that the language tag is expressed entirely in lowercase. Notice that the components of a language tag are separated by `-`.

### **Translation ID**

There are a number of translations even within a language group. This is even discounting the 200 English translations. Consider, for example, the New International Version (NIV). The code for this translation could well be NIV. But there are many versions of the NIV. These can be further identified, separated by a hyphen \- as in a language tag. Thus `niv-1978`.

The implications of this naming scheme is for some kind of registry or registries. For any given language tag, there needs to be one list of translation ids, even if only to have an implicit id for the language tag, such that if a new translation comes along, the old default, empty id, keeps referring to the same translation, if so desired. In the case of English, which is the one language that is the outlier of complexity for this system, there needs to be an agreed registry. While such a registry is needed for this standard, it is beyond the scope of this standard to specify one or to be dependent on its existence. Such a registry might then, for example, equate niv and niv-2011. This equivalence could change in the future.

### **Product ID**

When it comes to a verse reference, the product ID is unlikely to be needed. The product ID may be used to identify different scripture products associated with the translation. Examples of products would be various study editions. Again, there needs to be a list for each translation id of the recognised product ids. How this is managed is outside the scope of this standard.

To alleviate the need somewhat, we propose that the default product id for a translation be `text`. This allows other product ids to be added without having to first define a default. In effect `en+niv.GEN` is the same as `en+niv+text.GEN`.

## **Within a Verse Reference**

Given the various separations for components in a reference, we need to find something suitable. The good news is that this separator is used to extend the book ID. We can, therefore, use the same separators as used between a chapter and a verse. Thus, we propose using the same separator.

## **Conclusion**

Bringing all this together, a reference to a different translation might look like:

```
en-gb+niv-1978+study.JHN 3:16
```

The first component is the language tag (which has two parts: language and region) and identifies the Anglicised NIV translation over the US English version. Then comes the translation ID,  the 1978 edition of the NIV. Then within the translation there is the particular product, the NIV study bible. These are separated from the book code, which in turn is separated from the chapter:verse by a space. If the precise version of the NIV is not needed, a less precise translation id may be used. For example `en-gb+niv+study`, or even `en-gb+niv`.

Integrating this definition into our grammar, we get:

```
BookId = (TransId (":" | "."))? BookCode
BookCode = capital (capital | digit){2}
	   | digit (capital{2} | digit capital | capital digit)
TransId = langtag ("+" transcode ("+" productid)?)?
langtag = lang ("-" script)? ("-" region)? ("-" variant)*
	    ("-" ns ("-" extval)+)*
lang = letter{2,3} ("-" extlang)?
extlang = letter{3}
script = letter{4}
region = letter{2}
variant = letter{5,8}
ns = letter
extval = letter{5,8}
transcode = id
productid = id
id = idinit (idmid* idfinal)?
idinit = letter
idmid = letter | digit | "-" | "_"
idfinal = letter | digit
```

A full BCP47 language tag is more complex than presented here. This grammer only accounts for the common language tags that are in use today. See BCP47 for the full format definition, including definitions of `variant`, `ns` and `extval`.

# **Word And Character References**

At the other end of the scale is the desire to reference words or even characters within a verse. Extending the range model where we say that a chapter is a range of verses, we can say that a verse is a range of words and a word is a range of characters. There are various issues to address with this model:

* What constitutes a word? Most languages have a clear word break (a space), but some do not. Care needs to be taken in specifying a word break model.  
* Scripture can contain both primary scripture text and also out of band associated text in the same scripture file, like footnotes or other items.  
* At the character level there is the question of what constitutes a character? Is text, in Unicode terms, interpreted as NFD or NFC? Is punctuation considered part of a ‘word’?  
* How are word and character references included in a reference unambiguously?

Since a scripture reference is designed to identify the same ranges regardless of the serialisation of the text, whether in USFM, USX or USJ, the text is analysed without any character level markup. For example, \\\~ in USFM is a single \~ character and not two characters. Likewise \&emdash; in USX is a single character and not a word.

## **Word segmentation**

Accurate word segmentation is a difficult problem, particularly for non-wordspaced languages. Such languages do not have spaces between words, instead they use spaces as discourse or grammatical markers. Thankfully there are some factors in our favour. Scriptural texts are highly controlled. By this we mean that such texts are carefully edited and characters that would otherwise be missing from normal documents in a language, can and are inserted in scripture text. A primary example  of this is the zero width space (ZWSP, U+200B). This invisible character acts like a space for word segmentation and Iinebreaking, but otherwise is not seen. Therefore we can assume that any necessary character for word segmentation can be inserted.

Linguistically accurate word segmentation is not required. The reason for character locations to be identified by word is that it makes indexing by humans easier. Humans are not expected to come up with character level references over a long range of characters. So refining a range to a word first before counting characters is helpful. Thus it is sufficient for a ‘word’ in this context, to be defined as a sequence of non-space characters whether those characters are strictly word\-forming or not. This also mitigates any arguments over what is truly a word or not in a particular language.

While the USFM standard considers any space characters other than those in ASCII (i.e. space, tab, carriage return, newline) to be content characters that must not be changed, they are not considered word\-forming in any way. They are also often effectively invisible in that it is not possible to count how many space characters are in a sequence. Punctuation characters are also non-word-forming, but are visible and countable. Therefore we include them as being referenceable. Also this mitigates the question of when a punctuation character gets used as a word\-forming character. A marker is treated as a space. Multiple spaces are treated as a single space. The precise set of space characters is yet to be decided but will probably be closely aligned to \\p{Zs} (Unicode character of general category Zs which includes all the various space characters. We extend the list to include U+200B.)

In summary, a word is a sequence of non-space characters (as per the definition of a space above). In addition a marker or element delimits a word. Thus

`anthro\f + \ft human\f*pomorphic`

Is two words.

Word and character indexing are 1 based, that is the first word is numbered 1 and so on. As with verse numbers, we reserve the word "end" to signify the last word in a verse. We can use the 0th word to reference material before the first word. This only has meaning for markers with arguments: chapter numbers, verse numbers, footnote callers. For example someone wanting to associate, say a recording of the verse number could use MRK 1:1\!0.

*Use of :0 and \!0 should switch to referencing attributes thus MRK 1:1\!number*

## **Normalization**

The normalization encoding model question is relatively easy. We just have to pick one. The relative strengths and weaknesses of NFC vs NFD are:

### **NFC**

This is the most common way that data is stored. Given NFC and NFD are canonically equivalent, there is no content difference between the two normal forms.

### **NFD**

The problem with NFC is that some characters, for example: é, which is one code in NFC, but two in NFD may need to have its diacritic individually referenced, and for this we need to use NFD.

### **Conclusion**

Given the need to be able to reference components in precomposed characters, referencing needs to index characters based on NFD encoding. There may be better arguments why this decision should be reversed.

## **Character References**

Within a word, we consider characters, as discussed above. Characters, therefore, are indexed from the beginning of a word. Even a character is a range, it consists of the character plus any non scriptural text groupings following it, as will be discussed later. But it also includes the gap between it and the next scriptural character.

There are times when it is desirable to associate information with such a gap, for example implied Hebrew morphology. We use an extra \+ for this. Accessing the position before a word can use character position 0, for example `GEN 2:3!4+0+`.

*Do we need that final 0+? Could we just have GEN 2:3\!4+ for 'before word 4'? Or even GEN 2:3\!4+0.*

As with verses and words, we support the use of "end" for the end of a word. The range of values for a character index is 0 to the length of the word in characters, inclusive. Thus a character reference may not reference outside the  word it is based on.

Another option for character referencing is to use grapheme cluster offsets rather than character offsets. This would alleviate the need to specify a normalization form. There are two problems with this

* Precisely what constitutes a grapheme cluster is an open debate in a number of scripts. Even suggesting it is simply /.\\p{M}\*/ can cause problems.  
* There are users who would like to be able to reference individual diacritics for morphological purposes.

*Due to the Normalization question, character references are not designed for human consumption or entry.*

## **Syntax**

### **Separators**

Word and character components of a reference fit most naturally after the verse number. We cannot use the existing chapter separator after a verse number because that would cause all kinds of confusion at whether 1:2 means chapter 1 verse 2 or verse 1 word 2\. It is better to use a different separator. We propose \! and \+. For example GEN 2:3\!4+5 is Genesis chapter 2 verse 3 word 4 character 5\. It might be tempting to use character separators after a \! but this can cause confusion when dealing with the component hierarchy.

| Range | Description |
| :---- | :---- |
| `GEN 7:8!2-6` | Genesis ch 7 vs 8 words 2-6 |
| `GEN 7:8!2-12!3` | Genesis ch 7 vs 8 word 2 to vs 12 word 3 |
| `wsg-gong.JHN 3:16` | John 3:16 from the Gondi translation and Gunjala script |
| `en-t-wsg:JHN 3:16` | John 3:16 from the Gondi back translation into English |
| `en-t-wsg.MAT 1:1!5+6` | All that for a single letter\! (6th letter of 5th word in Mat 1:1) |

### **Grammar Extensions**

```
Verse = VerseNum WordRef?
VerseNum = digits (subverse)? | "end"
WordRef = "!" (digits | "end") Charref?
Charref = "+" (digits | "end") "+"?
ContextRef = Chapter (chaptersep Verse)? | Verse | WordRef | Charref
```

This grammar is technically ambiguous. For example a reference that consists only of a sequence of digits may be a chapter or a verse or a wordref or a charref. It is only in the context of another reference that the ambiguity may be resolved. Notice also that \! and \+ disambiguate whether the digits that follow are a word or character reference. Given the grammar structure, this is not strictly necessary. But it is easier on the eye.

# **Non Scriptural Text**

Scripture files consist of more than just pure scripture text. They often contain subheadings, footnotes, cross references, and introductory paragraphs. They also contain introductory paragraphs to set things like table of contents identifiers, headers, etc. Markers may have attributes that contain extra information. There are different categories of markers and how they work with regard to referencing.

## **Notes**

Notes include footnotes and cross references. They are anchored following a particular character. As stated earlier a character reference is a range including all the non scriptural text following the character. For example, consider this USFM fragment:

```
\v 2 Hello\f + \fr 1:2\ft A greeting\f* everyone
```

A reference to the word greeting might be: `1:2!1!f!3` This is a reference to chapter 1 verse 2, the first word (which includes the following note, since it is part of the last character of the word), the first f marker following and ~~the~~ its 3rd word (considering the `\fr 1:2` as the first word). The reference could also be shortened to `1:2!f!3`. This is interpreted as chapter 1 verse 2, the first f marker in the verse and its 3rd word.

If there is more than one occurrence of a marker in a range and we want to reference after the first, we use `[]` as in `1:2!f[3]`. Notice that we count from 1, thus `1:2!f` is equivalent to `1:2!f[1]`.

This can go further. Thus in

```
\v 2 Hello\f + \cat rephrase\cat*\fr 1:2\ft A greeting\f* everyone
```

The category may be referenced as `1:2!f!cat`.

In addition, since we are working with a USX based model, the caller may be accessed as an attribute as in `1:2!f!caller`.

## **Section Headings**

It is awkward to refer to a section heading in terms of the verse that precedes it. In effect, section paragraphs are associated with the text that follows them, rather than the text that precedes them. Consider this example USFM fragment:

```
\c 1
\p
\v 12 At once the Spirit made him go into the desert, \v 13 where he stayed 40 days, being tempted by Satan. Wild animals were there also, but angels came and helped him.
\s1 Jesus Calls Four Fishermen
\r (Mt 4.12-22; Lk 4.14-15; 5.1-11)
\p
\v 14 After John had been put in prison, Jesus went to Galilee and preached the Good News from God.
```

The subheading text in the `\s1`[^2] is associated with 1:14 rather than 1:13. We might reference the word Four via `1:14!s1!3`.

By saying that non verse paragraphs are associated with the first word in the following verse paragraph, we get around any confusion. For example, if a subheading occurs before a paragraph that does not start with a new verse, then the subheading is associated with the first word of the new paragraph, and so as part of the previous verse.

In some rare cases it may be that non section material occurs between the start of a chapter and verse 1\. To reference this, we allow a verse 0\. This allows the text of a chapter number  to be referenced as `MRK 1:0` for example. Strictly, if there is other pre verse 1 material, that starts with the first word. The chapter number is actually the 0th word. So the chapter number is also `MRK 1:0!0`. Per chapter labels are treated as section paragraphs. But a repeated chapter label prefix is different. Consider this example:

```
\cl Chapter
\c 1
\s1 The Start of Something New
\p
\v 1 The disciples were in awe.
```

The initial `\cl` here specifies a prefix label for all chapters. Thus the chapter label for chapter 1 would be `Chapter 1`. This content occurs before the section headings, and while a normal `\cl` entry (following the chapter number) would be treated as section heading material associated with verse 1, this data is part of the chapter number and so is considered pre verse 1 material. The actual chapter *number* is `MRK 1:0!2` and the whole chapter label with its number is MRK `1:0`.

Chapter and verse numbers are also available as attributes: `MRK 1:0!number` or  `MRK 10:3!number`. 

## **Introductory Paragraphs**

How do we reference introductory material in a file before chapter 1? There is no verse to anchor this material to. Again, using the idea of range refinement, we can treat the whole book as a range and then refine it based on the nth occurrence of a marker in a file. For example:

```
\id MRK - Good News Study Bible - Notes Material
\is1 The Story
\ip \bk Mark's\bk* story of Jesus is told quickly and with an abundance of details that enhance its dramatic impact. Jesus appears suddenly in Judea, where he joins those who are being baptized in the Jordan by John the Baptist. Just as suddenly, he returns to Galilee, where he proclaims the message that the \w kingdom of god\w* is about to arrive…
\c 1
\p
\v 1 sample verse
```

There are a couple of ways to refer to the word  kingdom here. MRK 0\!ip\!53 involves a lot of counting. This is not uncommon with lots of introductory material. Notice that all the text in the marker is included, even the primary text in any markers within that paragraph. Alternatively  MRK 0\!ip\!w\!1 does the job. This is again based on range refinement. MRK \!ip refines the book of Mark to the first ip marker contents. Within that we refine further using \!w to the first w marker contents and then we find the first word in that.

## **Attributes**

Character markers may take attributes. For example:

```
\v 1 L'\w Éternel|strong="H3068"\w* \w dit|strong="H559" x-morph="strongMorph:TH8799"\w* à \w Abram|strong="H87"\w*: Va-t-\w en|strong="H3212" x-morph="strongMorph:TH8798"\w* de ton.
```

Things can get messy when auto generated text gets involved\! For some strange reason we want to refer to the strong attribute for the 8th word en (L',  Éternel, dit, à, Abram, :, Va-t-, en). It has a value of H3212. There are different ways of writing the reference. `1:1!8!strong` counts to the 8th word. Notice that while there is no space before the `\w`, it is considered a separate word. Alternatively the reference might be: `1:1!w[4]!strong` which counts `\w` and then gets the strong attribute.

To make things easier, we consider a marker's attributes to be associated with every character in the main text of the marker. Milestones, of course, have no main text in the marker and so the attributes can only be referenced via the milestone marker, as per the second reference in the example above.

Due to the overloading of \! there is a constraint that attribute names cannot be the same as contained marker names.

## **Paragraphs**

The proposed mechanism also allows for further limiting a verse range to a particular paragraph within that verse range. This isn't strictly non-scriptural text, but the same mechanism applies. Consider the following fragment:

```
\p
\v 9 Then the \w disciples\w* said, “Teacher! What is the meaning of this parable?” they asked Jesus.
\v 10 So Jesus said, “God gave you the knowledge to know about his kingdom. But in order to fulfil that which is written in scripture, I am telling them with parables. Therefore
\q1 ‘They will look but not see [it],
\q2 they will listen but they don't understand’
\m he told like that the disciples.
```

Which occurs in LUK 8\. We can reference the q1 paragraph as `LUK 8:10!q1` with or without the `[1]`. A key question is: how can we reference the text from the start of verse 10 up to the start of the q1 paragraph? The reference `LUK 8:10` consists of everything in this example following `\v 10`.  We need, somehow, to be able to reference the containing paragraph. And this is what we allow. The containing paragraph is considered to be the first paragraph before a reference. Thus `LUK 8:10!p` references just the text in the verse in its containing paragraph (which is of type p). Unfortunately, this makes implementing reference range extraction something beyond what a regular expression can handle (even if it could handle all the rest\!)

## **Conclusion**

Non scriptural elements are handled by attaching them, as if they were children, to a character in the scripture text, or to the start of the book, before chapter 1\. This table summarises the actions taken.

| section and other non-verse paragraphs | the next scripture text 1st character |
| :---- | :---- |
| Introductory material before `\c 1` | `BK 0:0!0+0` |
| Notes, milestones, figures, etc. | the previous scripture text character |

Notice that associating an element with a character does not require a character level reference to access it. For example, referencing the caption of a figure that occurs half way through 3:7 may be referenced simply as `3:7!figure`. But it may also be referenced as `3:7!10!figure` as it follows the 10th word, or even `3:7!10!8!figure` as following the 8th and final character. But usually the word and or character indices are redundant detail that only makes the reference less resilient to edits to the text.

## **Syntax**

The grammar needs extending. First we extend wordref to include marker references:

```
Wordref = ("!" digits Charref?)? Mrkref?
Mrkref = "!" id ("[" digits "]")? Wordref?
```

An id may not finish with a \- otherwise it might look like the start of a range.

Secondly we need to loosen a reference to allow not having to reference down to a verse, per se.

```
FullRef = BookId ws+ (Chapter (chaptersep Verse)?)? Wordref?
ContextRef = (Chapter (chaptersep Verse)? | Verse)? Wordref?
```

Syntactically, \! followed by a non-digit, identifies a marker reference, while \! followed by a digit always identifies a word reference.

# **Identifiers**

There is a proposal to add an identifier attribute to a number of the nodes in a USX file, with the necessary extensions to USFM to support them in the USFM serialisation. The document [U25002](https://docs.google.com/document/d/1Ij1jQdGnawiVuOUhC1fxK44DcMcekm-ZTz8bAVF8eDw/edit?tab=t.0#heading=h.kw9nq8nxaljt) has a full discussion of the proposal. To integrate this into U23003 will take an extension to the syntax. Specifically the C:V (or C.V) needs the C to be allowed to be one or more lowercase letters and in that case for the V to be a string according to the limits on a keyword identifier from U25002:

The identifier is constrained as follows:

* No character in the identifier may include any of these: \[\\p{P}\\p{C}\\p{Z}\]  
* An identifier may also not include any of these characters[^3] \['"\!+@\#&\\-.:|\\\\\\\[\\\]\<\>()\]  
* In addition, the first character in the identifier is further limited by not including \\p{M}  
* Any characters that may not be included in the identifier are simply removed from the keyword string to create the identifier

```
Reference = FullRef | ContextRef | NameRefNameRef = BookId (ws+ Namespace chaptersep Nameval) Wordref?Namespace = letter+
Nameval = NameInit NameChar*
NameChar = [[:any:]-\p{P}\p{C}\p{Z}'"!+@#&\-.:|\\\[\]<>()]
NameInit = [[:any:]-\p{M}\p{P}\p{C}\p{Z}'"!+@#&\-.:|\\\[\]<>()]
```

# **Conclusion**

Here we bring together all the grammar fragments into a complete grammar:

```
Reflist = RefRange (ws* refsep ws* RefRange)*
refsep = ";" | ","
RefRange = Reference (ws* "-" ws* Reference)?
Reference = FullRef | ContextRef | NameRefNameRef = BookId (ws+ Namespace chaptersep Nameval) Wordref?Namespace = letter+
Nameval = NameInit NameChar*
NameChar = [[:any:]-\p{P}\p{C}\p{Z}'"!+@#&\-.:|\\\[\]<>()]
NameInit = [[:any:]-\p{M}\p{P}\p{C}\p{Z}'"!+@#&\-.:|\\\[\]<>()]

FullRef = BookId (ws+ Chapter (chaptersep Verse)? Wordref?)?
ContextRef = Chapter (chaptersep Verse)? Wordref?
    	| Verse Wordref? | WordrefOnly Mrkref* | Charref Mrkref*

BookId = (TransId booksep)? BookCode
booksep = ":" | "."
BookCode = capital (capital | digit){2}
  	| digit (capital{2} | digit capital | capital digit)
TransId = Langtag ("+" Transcode ("+" Productid)?)?
Langtag = Lang ("-" Script)? ("-" Region)? ("-" Variant)*
           	("-" Ns ("-" Extval)+)*
lang = letter{2,3} ("-" Extlang)?
Extlang = letter{3}
Script = letter{4}
Region = letter{2}
Variant = letter{5,8}
Ns = letter
Extval = letter{5,8}
Transcode = id
Productid = id

chaptersep = ":" | "."
Chapter = digits
Verse = digits Subverse? | Subverse | "end"
Subverse = letter
wordrefSep = "!"
WordrefOnly = (digits | "end") (charrefSep Charref)?
Wordref = (wordrefSep WordrefOnly | Mrkref) Mrkref*
charrefSep = "+"
Charref = (digits | "end") "+"?
Mrkref = "!" id ("[" digits "]")? (wordrefSep WordrefOnly)?

id = idinit idmid* idfinal?
idinit = letter | "_"
idmid = letter | digit | "_"
idfinal = letter | digit
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
digits = digit+
ws = " " | [\u00A0\u1680\u2000-\u200F\u202A-\u202F\u205F
        	\u2066-\u2069\u3000]
letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
   	"k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" |
   	"u" | "v" | "w" | "x" | "y" | "z"
capital = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" |
    	"K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" |
    	"U" | "V" | "W" | "X" | "Y" | "Z"
```

# **Appendix 1\. Book Codes**

The following is the standard list of book codes for purposes of interchange.	

| 3 Ltr | Index[^4] | Name |
| :---- | :---- | :---- |
| GEN | 01 | Genesis |
| EXO | 02 | Exodus |
| LEV | 03 | Leviticus |
| NUM | 04 | Numbers |
| DEU | 05 | Deuteronomy |
| JOS | 06 | Joshua |
| JDG | 07 | Judges |
| RUT | 08 | Ruth |
| 1SA | 09 | 1 Samuel |
| 2SA | 10 | 2 Samuel |
| 1KI | 11 | 1 Kings |
| 2KI | 12 | 2 Kings |
| 1CH | 13 | 1 Chronicles |
| 2CH | 14 | 2 Chronicles |
| EZR | 15 | Ezra |
| NEH | 16 | Nehemiah |
| EST | 17 | Esther |
| JOB | 18 | Job |
| PSA | 19 | Psalms |
| PRO | 20 | Proverbs |
| ECC | 21 | Ecclesiastes |
| SNG | 22 | Song of Songs |
| ISA | 23 | Isaiah |
| JER | 24 | Jeremiah |
| LAM | 25 | Lamentations |
| EZK | 26 | Ezekiel |
| DAN | 27 | Daniel |
| HOS | 28 | Hosea |
| JOL | 29 | Joel |
| AMO | 30 | Amos |
| OBA | 31 | Obadiah |
| JON | 32 | Jonah |
| MIC | 33 | Micah |
| NAM | 34 | Nahum |
| HAB | 35 | Habakkuk |
| ZEP | 36 | Zephaniah |
| HAG | 37 | Haggai |
| ZEC | 38 | Zechariah |
| MAL | 39 | Malachi |
| MAT | 41 | Matthew |
| MRK | 42 | Mark |
| LUK | 43 | Luke |
| JHN | 44 | John |
| ACT | 45 | Acts |
| ROM | 46 | Romans |
| 1CO | 47 | 1 Corinthians |
| 2CO | 48 | 2 Corinthians |
| GAL | 49 | Galatians |
| EPH | 50 | Ephesians |
| PHP | 51 | Philippians |
| COL | 52 | Colossians |
| 1TH | 53 | 1 Thessalonians |
| 2TH | 54 | 2 Thessalonians |
| 1TI | 55 | 1 Timothy |
| 2TI | 56 | 2 Timothy |
| TIT | 57 | Titus |
| PHM | 58 | Philemon |
| HEB | 59 | Hebrews |
| JAS | 60 | James |
| 1PE | 61 | 1 Peter |
| 2PE | 62 | 2 Peter |
| 1JN | 63 | 1 John |
| 2JN | 64 | 2 John |
| 3JN | 65 | 3 John |
| JUD | 66 | Jude |
| REV | 67 | Revelation |
| TOB | 68 | Tobit |
| JDT | 69 | Judith |
| ESG | 70 | Esther Greek |
| WIS | 71 | Wisdom of Solomon |
| SIR | 72 | Sirach also Ecclesiasticus |
| BAR | 73 | Baruch |
| LJE | 74 | Letter of Jeremiah |
| S3Y | 75 | Prayer of Azariah and the Song of the Three Jews |
| SUS | 76 | Susanna |
| BEL | 77 | Bel and the Dragon |
| 1MA | 78 | 1 Maccabees |
| 2MA | 79 | 2 Maccabees |
| 3MA | 80 | 3 Maccabees |
| 4MA | 81 | 4 Maccabees |
| 1ES | 82 | 1 Esdras (Greek) |
| 2ES | 83 | 2 Esdras (Latin) |
| MAN | 84 | Prayer of Manasseh |
| PS2 | 85 | Psalm 151 |
| ODA |  | Odes |
| PSS |  | Psalms of Solomon |
| JSA |  | Joshua A. |
| JDB |  | Joshua B. |
| TBS |  | Tobit S. |
| SST |  | Susanna Th. |
| DNT |  | Daniel Th. |
| BLT |  | Bel Th. |
| 3ES |  | 3 Ezra |
| EZA |  | Apocalypse of Ezra |
| 5EZ |  | 5 Ezra |
| 6EZ |  | 6 Ezra |
| DAG | B2 | Daniel (in Greek) |
| PS3 |  | Psalms 152-155 |
| 2BA |  | 2 Baruch (Apocalypse) |
| LBA |  | Letter of Baruch |
| JUB |  | Jubilees |
| ENO |  | Enoch |
| 1MQ |  | 1 Meqabyan/Mekabis |
| 2MQ |  | 2 Meqabyan/Mekabis |
| 3MQ |  | 3 Meqabyan/Mekabis |
| REP |  | Reproof (Proverbs 25-31) |
| 4BA |  | 4 Baruch (Rest of Baruch) |
| LAO | C3 | Letter to the Laodiceans |
| FRT | A0 | Front Matter |
| GLO | A9 | Glossary / Wordlist |
| CNC | A8 | Concordance |
| XXA | 94 | Extra Material |
| XXB | 95 | Extra Material |
| XXC | 96 | Extra Material |
| XXD | 97 | Extra Material |
| XXE | 98 | Extra Material |
| XXF | 99 | Extra Material |
| XXG | 100 | Extra Material |
| XXS | 101 | Extra Material (not in PT) |
| BAK | A1 | Back Matter |
| OTH | A2 | Other Matter |
| INT | A7 | Introductory Peripherals |
| TDX | B0 | Topical Index |
| NDX | B1 | Names Index |

# **Outstanding Issues**

## **Resilience to Editing**

The problem with such a surgically precise referencing scheme is that any change to the text can cause problems and the reference is no longer valid. This is true for anything index based: words, characters, markers. Of the three, the one that is most likely to cause problems is the word index. Adding or removing a word can cause significant problems to say study material insertion.

To give a word (or lower) reference greater resilience, we allow the actual word itself to be included in the reference. Thus for the sample:

```
\v 2 Hello\f + \fr 1:2\ft A greeting\f* "everyone"
```

A reference might be extended to include the word text: `1:2!2%"everyone"+5-7`. This would allow a processor to realign should the underlying text be changed to, for example add text:

```
\v 2 Hello\f + \fr 1:2\ft A greeting\f* "everyone"
```

Notice that the word is included exactly as is, including any attached punctuation. We could decide to allow the word to be a subsequence of characters within the word. But then the probability of collisions goes up, even as the word becomes more resilient to textual changes.

Of course, such realignment is limited. It would not support changing the word itself (by character edit or word change). The question therefore, is: given that this solution only solves part of the problem, is it worth the extra cost?

### **Statistical Analysis**

Some statistics regarding how many repeated words there are in a verse. Of course the stats are not helped by translators grouping a whole genealogy into a single verse range\!

A survey over 280 million words across different projects gives the following approximate statistics for percentages of verses with a given number of word repeats:

| number | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Words% | 71.63 | 16.57 | 5.892 | 2.7238 | 1.3645 | 0.7304 | 0.4033 | 0.2473 | 0.1448 |
| Verses% | 99.94 | 75.49 | 34.47 | 15.11 | 6.6804 | 3.172 | 1.555 | 0.834 | 0.446 |

16% of all the words are duplicated in a verse. A duplicate counts as 2 words. Notice how all the word percentages sum to 100%. An alternative view is that 75% of verses contain a duplicate. In each case numbers are not cumulative. The score for 3 is not added into the score for 2\. That's a lot of possible collisions.

Let's look at bigrams, are the results any better?

| number | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| Words% | 93.761 | 5.126 | 0.7678 | 0.2063 | 0.0792 | 0.0284 | 0.0118 | 0.0086 | 0.0024 |
| Verses% | 99.892 | 31.39 | 4.854 | 1.094 | 0.336 | 0.1062 | 0.0383 | 0.0203 | 0.0063 |

31% of verses have a duplicate bigram? That's a surprise. Not sure what this tells us.

### **Conclusion**

The statistics are pretty poor as to contextual word references colliding within a verse. Given that this approach doesn't seem to adequately solve the contextual problem, the costs of supporting such an approach everywhere outweighs the probability of benefit and so we propose not using this solution.

Synchronising references following editing is a difficult problem. It involves identifying the impact a difference to some text makes to the references into that text. Thankfully, there is some inbuilt resilience in the book, chapter, verse structure which is clearly identified in the text. For some, losing synchrony such that a reference falls back to the beginning of a verse is considered a failure. But for many users, it is preferable to losing the reference entirely or it pointing outside the verse. 

## **Refer to Scriptural content only**

One use case that may well be out of scope but worth discussing is for the Oral BT world: it would be helpful to have a reference that basically means only the scriptural content (which would usually be recorded). This may be within a verse, verse range or larger sections (e.g. chapter). So for example, if a verse contains footnotes, the reference should be able to semantically point to only the scriptural text without the footnote. Though it would be nice if there is an easy way to pinpoint the indices but using the above scheme as-is for this purpose would be verbose.

There are two aspects to this issue: the ability to reference up to but not including an associated note and the need to be able to do this. The problem with the assumption that this is needed is: what is a processor to do with notes within a range (e.g. a verse)? An initial analysis of the problem is that it is up to the processor to filter the contents for what it wants, whether that is just the scripture text or whether it includes side material. This includes decisions about sub headings, references, verse numbers, notes, etc.

If it is necessary to reference text up to but not include a following note, for example, we might define the between character position as not including any attached note. This is because the assumed use for such a position is as a non character in a word. This would give the odd case that an range ending in say 1\!20+10 would include a note but 1\!20+10+ would not. This is somewhat arbitrary, if a solution to an obscure need.

## **Verse Ranges**

Not all verses are a single verse. Some translations translate a block of verses as a unit block. This is often because the discourse structure calls for text in a later verse to occur earlier. How can such verse ranges or lists be referenced?

One solution is to provide an escaping mechanism to allow such characters as \- and , to occur in a verse element. For example `JHN 11:"35-36"-37`. Another solution is to treat such a verse range or list, just as that and to intersect that range with the verse range in the reference. Thus, for example.

```
\c 11
\v 35-36 The Jews saw that Jesus wept and said how much he loved him.
\v 37 But some cynically asked …
```

So what does `JHN 11:36` refer to? In effect our reference expands to `JHN 11:35-36`. What about asking for `JHN 11:34-35`? By extension this becomes `JHN 11:34-36`.

How about verse lists. Consider

```
\v 1,3,5 Some text
\v 2 With this
\v 4 and this.
```

Now `1:2-3` expands to `1:1-3`, including the first verse set. "Some text with this".

## **USFMPath** 

Wouldn't it be nice if we could write a reference based on the content of the text? For example glossary entries based on the value of the \\k element in it. At this point we are entering the same kind of referencing found in xpath. For example, if we wanted all the verses in JHN containing the 'light' keyword, we might write `JHN *:*[equals(k, light)]`. But that would be absurd, right? Maybe this would be appropriate for a follow-on standard.

## **English Translation Identifiers**

For most language groups, the number of translations is small and while there may be no formal registry, people can interpret an identifier relatively simply. But there are many English translations and each translation has multiple sub products. Thus the process of creating translation identifiers for English translations is probably the most complex.

Strictly speaking, the process of creating a translation identifier is out of scope for this standard. We simply state that there is one and that this is where you can use it. But since this is the first that many have had a chance to think about translation identifiers, it is worthy of some discussion.

This standard allows for both the translation code and the product code to have sub components, which are intended to provide increased refinement. Thus `niv` incorporates all subcomponents of the NIV, e.g. `niv-1978`, `niv-2011`, etc. The intention therefore, is that the owner of a particular translation take charge of the registry of subcomponents and product ids and that any pan English registry just keep track of the top level translation codes along with links to where information may be found on the subcomponents and the product ids.

Most translation variants are driven by language and so the language tag preceding can often address such variants. Thus `en+niv` would be the current NIV in US English, while the anglicised version would be `en-gb+niv`.

One idea might be to use the ISBN for the product id. This is probably not a good idea since the hardback version of a book has a different ISBN to the softback, etc. The purpose of the translation id is to identify a text that someone wants to refer into. The use of product ids, therefore, is likely to be rare, since product ids would typically be used for textual additions, like study bibles, and so only needed where someone wants to refer into those textual additions as opposed to the main scripture text.

In my ideal world, each translation listed in a world database of such things would have a language tag and translation id. For product ids, the database could refer to either a publisher's list or their own. But given how rarely product ids should need to be used, allocation could well be on an as needed basis rather than trying to list all products for a translation (which could be large in some cases).

# **Implementation**

This section contains various non-normative notes regarding implementation.  For the most part, the notes are to aid conceptual understanding more than efficient implementation.

## **Type Model**

This type model gives a structure for easy referencing.

### **Element**

An element is an XML element with requisite attributes and content. An element also holds any significant whitespace that occurs immediately following the closing tag, i.e. after the end of the element.

```
Element:
	Contents: List[Element | Word]
	Attributes: Map[Str, Str]
	Tail: Str
	Next: Element | Word
```

### **Word**

A word consists of a sequence of characters. It also holds any following whitespace, since element initial whitespace is removed. A word may be preceded by a list of elements, if it occurs as the first word in a paragraph.

A character may have an associated list of notes. Since interword notes are common and intraword notes are rare, implementations may optimise for this.

```
Word:
	Contents: Str        	# NFD implies 1 USV per 'character'
	Tail: Str
	Before: List[Element]	# Optimised Attachments[0]
	After: List[Element] 	# Optimised Attachments[len(Contents) - 1]
	Attachments: Map[Int, List[Element]]
	Next: Element | Word
```

### **Indexing**

There are various ways of indexing chapters, verses and words. At the lower levels of word and verse, linked lists may prove most efficient.  If words are linked, it is probably prudent to link words and elements in document order, including verse and chapter elements, while not linking to non verse text or elements.

[^1]:  This is the proposal reference number in the USFM Technical Committee's document registry.

[^2]:  Markers themselves are not strictly part of any text, they are metadata governing the structure and formatting of the text. References are only concerned with text.

[^3]:  &\# are excluded to make life easier in HTML/XML

[^4]:  Current Paratext 9 Index code